---
title: "Boost with signals"
permalink: "y9max1"
---

The Boost With Signals query pipeline stage performs automatic boosts based on the contents of the aggregated signals collection. For this type of boosting, signals must be enabled but recommendations need not be.

Using the main query and the stage configuration parameters, this stage performs a secondary query to the `COLLECTION_NAME_signals_aggr` collection and returns updated boost weights for the items in the main query’s search results. Items that have received more user interaction also receive higher boost weights.

Some of the important configuration parameters are discussed below. For complete details about all configuration parameters for this stage, see [Boost with Signals](/managed-fusion/5.9/ihes2t/boost-with-signals-stage).

## Configuration overview

The fields below are especially useful to understand when configuring this stage.

<table>
  <colgroup>
    <col style="width: 25%;" />
    <col style="width: 75%;" />
  </colgroup>
  <tbody>
    <tr>
      <td>
        <strong>Number of Recommendations</strong><br/>
        <code>numRecommendations</code>
      </td>
      <td>
        <p>Sets the <code>rows</code> query param in the main query as the maximum number of query results which will be boosted by this pipeline stage.</p>
      </td>
    </tr>
    <tr>
      <td>
        <strong>Number of Signals</strong><br/>
        <code>numSignals</code>
      </td>
      <td>
        <p>Sets the `rows` query param in the query that searches the `COLLECTION_NAME_signals_aggr` collection, so only the specified number of aggregated signals are retrieved and used for boosting. When signals boosting is applied to a query, aggregated signals records are queried from a `}}{{_signals_aggr` collection to find out the popularity or boost weight for documents which have signals. `numSignals` limits the number of records to be queried from a `_signals_aggr` collection and used to calculate this boost.</p>
      </td>
    </tr>
    <tr>
      <td>
        <strong>Aggregation Type</strong><br/>
        <code>aggrType</code>
      </td>
      <td>
        <p>A filter to retrieve aggregated signals in the <code>COLLECTION_NAME_signals_aggr</code> collection per each aggregated signal’s <code>aggr_type_s</code> field value.</p>
      </td>
    </tr>
    <tr>
      <td>
        <strong>Solr Field to Boost On</strong><br/>
        <code>boostId</code>
      </td>
      <td>
        <p>The document field in the main collection on which to perform boosting. Typically it should use the default field, which is <code>id</code>.</p>
        <p>This field corresponds to the <strong>Rollup Field</strong>/<code>rollupField</code> field. Together, these two fields act like a <code>FIELD:VALUE</code> pair in the query modification for boosting.</p>
      </td>
    </tr>
    <tr>
      <td>
        <strong>Boost Method</strong><br/>
        <code>boostingMethod</code>
      </td>
      <td>
        <p>This adds a query parameter to the original query, either “query-param” or “query-parser”. The result is `“query-param”/“query-parser” + Boost Param (“boost” or bq)`, as in the examples below:</p>
          ```js “query-param”+"boost", result boost query param
          boost="map(query({!field f='id' v=‘6239046,13026192}), 0, 0, 1, 27.1705)"
          ```

          ```js “query-parser”+"boost", result boost query param
          bp_xxx_bbqx="map(query({!field f='id' v=‘6239046,13026192}), 0, 0, 1, 27.1705)"
          ```
        <Tip>
          When `Boost Param` uses `bq`, similar logic applies. When Boost Param/`boostingParam` uses “boost”, it works with both “query-param” and “query-parser”.
        </Tip>
      </td>
    </tr>
    <tr>
      <td>
        <strong>Rollup Field</strong><br/>
        <code>rollupField</code>
      </td>
      <td>
        <p>Indicates which aggregated signal document field the boost parameter will use for the final boosting. It works in combination with the <strong>Solr Field to Boost On</strong>/<code>boostId</code> field.</p>
        <p>This should be set to the field in the aggregated signal collection that stores the doc list that is aggregated as one record. By default it’s set to <code>doc_id_s</code>, because by default this is used in the <a href="/fusion/5.9/wuhhmm/sql-aggregations#click_aggr">click_signal_aggr SQL job</a>.</p>
      </td>
    </tr>
    <tr>
      <td>
        <strong>Rollup Weight Field</strong><br/>
        <code>rollupWeightField</code>
      </td>
      <td>
        <p>Indicates the final boost weight used to calculate the new score for docs retrieved by the main query.</p>
        <p>Similar to <strong>Rollup Field</strong>/<code>rollupField</code> above, this should be set to the field in the aggregated signal collection that stores the final weight that was calculated. By default it’s <code>weight_d</code>, because by default this is used in the <a href="/fusion/5.9/wuhhmm/sql-aggregations#click_aggr">click_signal_aggr SQL job</a>.</p>
      </td>
    </tr>
    <tr>
      <td>
        <strong>Final Boost Weight Expression</strong><br/>
        <code>weightExpression</code>
      </td>
      <td>
        <p>Calculates the final weight using the weight and score retrieved from the <code>COLLECTION_NAME_signals_aggr</code> collection.</p>
        <p>The default value is <code>math:log(weight_d + 1) + 10 * math:log(score+1)</code>.</p>
      </td>
    </tr>
  </tbody>
</table>

## Solr query parameters

These parameters are used in the **Solr Query parameters**/`queryParams` field for retrieving signal aggregation docs from the `COLLECTION_NAME_signals_aggr` collection. These Solr query params will affect which aggregated signals are used for producing the boosting parameter on the main query.

|  |  |
| --- | --- |
| `qf=query_t` | Defines which field to query. In the default case, the query searches on the `query_t` field of aggregated signal docs. |
| `pf=query_t^50` | Boosts docs within the set of retrieved docs using phrase matching. |
| `pf2=query_t^20` | `pf2` is similar to `pf`; the difference is that `pf2` works on bigram phrases. |
| `pf3=query_t^10` | `pf3` is similar to `pf`; the difference is that `pf3` works on trigram phrases. |

## FAQs

If there is `fq` in the main query, how is it matched with the correct aggregated signal?

In this case, you need to use the `lw.rec.fq` query parameter in the main query. `lw.rec.fq` can be parsed by the Boost with Signals stage, and therefore the filters specified in it can be added to the Solr query that is retrieving the aggregated signals.

For example, if we have filter query param `fq=format:CD&fq=name:Latin`, this needs to be translated into `lw.rec.fq=filters_s:"format:cd $ name:latin"`. Values must be lowercase. The final main query should be:

```
http://EXAMPLE_COMPANY.lucidworks.cloud/api/apps/demo_app/query-pipelines/demo_app/collections/demo_app/select?echoParams=all&wt=json&json.nl=arrarr&sort&start=0&q=apple&debug=true&rows=10&lw.rec.fq=filters_s:"format:cd $ name:latin"
```

<Note>
Replace `EXAMPLE_COMPANY` with the name provided by your Lucidworks representative.
</Note>

Now the Boost with Signals stage will only retrieve aggregated signals that have the same filter query.

<Note>
If there are multiple `fq` values (for example, `format:cd` and `name:latin`), they are ordered alphabetically as strings and joined with " $ " (a $ with a space on each side). In the example, `"format:cd $ name:latin"`.
</Note>

What if my aggregated signals are in a different collection?

You can point the Boost with Signals stage to a different signal collection by adding a `collection` parameter in the `Solr Query Parameters` section.

<Frame>![BwS collection](/assets/images/4.2/BwS_collection.png)</Frame>